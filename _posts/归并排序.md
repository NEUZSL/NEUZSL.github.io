---
layout: post
title:  "归并排序及其改进"
date:   2019-09-18 
categories: 数据结构与算法
tags: c++实现
1. "自顶而下"版实现代码
---
    template<typename T> 
       void mergeSort(T arr[], int n)//归并排序
    {
    	__mergeSort(arr,0,n-1);
    }

        //递归使用归并排序
    template<typename T>
    void __mergeSort(T arr[], int L, int R)
    {
    	if (L >= R)  //递归停止条件
    		return;
    	int mid = (R + L) / 2; //这个地方存在bug, 可能会溢出
    	__mergeSort(arr, L, mid);
    	__mergeSort(arr, mid+1, R);
    	merge(arr, L, mid, R);
    }

    template<typename T>
    void merge(T arr[], const int L,const int mid, const int R)
    {
    	T aux[R - L + 1];//在此编译器里面不能如此定义
    	T *aux;
    	aux = new T[R - L + 1];//开辟内存大小需要注意
    	for (int i = L; i <= R; ++i)
    		aux[i - L] = arr[i];  //此处要减去偏移量
    	int i = L, j = mid + 1;   //在这样定义以后，下面的aux[]操作时不要忘记减去偏移量
    	for (int k = L; k <= R; ++k)
    	{
    		if (i > mid)
    		{
    			arr[k] = aux[j-L];
    			j++;
    		}
    		else if(j > R)
    		{
    			arr[k] = aux[i-L];
    			i++;
    		}
    		else if (aux[i-L] < aux[j-L])
    		{
    			arr[k] = aux[i-L];
    			i++;
    		}
    		else 
    		{
    			arr[k] = aux[j-L];
    			j++;
    		}
    	}
    }

上述代码实现参考
> https://github.com/liuyubobobo/Play-with-Algorithms

上述算法可以改进的地方
---
    //递归使用归并排序
    template<typename T>
    void __mergeSort(T arr[], int L, int R)
    {
    	if (L >= R) //可以优化地方1 
    		return;
    	int mid = (R + L) / 2; 
    	__mergeSort(arr, L, mid);
    	__mergeSort(arr, mid+1, R);
    	merge(arr, L, mid, R);//可以优化地方2 
    }

改进后的代码

    template<typename T>
    void improvedMergeSort(T arr[], int n)//改进的归并排序
    {
    	__improvedMergeSort( arr, 0, n - 1);
    }

    template<typename T>
    void __improvedMergeSort(T arr[], int L, int R)
    {
    	if (R - L <= 15)//15这个值参考值
    	{
    		improvedInsertionSort(arr,L,R);//调用插入排序(这里的插入排序略作修改)
    		return;
    	}
    	int mid = (R + L) / 2;
    	__improvedMergeSort(arr, L, mid);
    	__improvedMergeSort(arr, mid + 1, R);
    	if(arr[mid+1]>arr[L])
    	 merge(arr, L, mid, R);
    }

    template<typename T>
    void improvedInsertionSort(T arr[], int L, int R) //改进的插入排序
    {
    	
    	for (int i = L; i <= R; ++i)
    	{
    		T e = arr[i];
    		int j;
    		for (j = i; j > 0 && e < arr[j - 1]; --j)
    			arr[j] = arr[j - 1];
    		arr[j] = e;
    	}
    }
时间复杂度分析
---
> https://blog.csdn.net/bluetjs/article/details/52485920

参考上述博客

其他
---
Check out the [Jekyll docs][jekyll] for more info on how to get the most out of Jekyll. File all bugs/feature requests at [Jekyll’s GitHub repo][jekyll-gh]. If you have questions, you can ask them on [Jekyll’s dedicated Help repository][jekyll-help].

[jekyll]:      http://jekyllrb.com
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-help]: https://github.com/jekyll/jekyll-help




